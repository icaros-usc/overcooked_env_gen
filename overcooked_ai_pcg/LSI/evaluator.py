"""Defines a Ray remote function for running evaluations."""
import gc
import resource
import numpy as np

from overcooked_ai_pcg.GAN_training import dcgan
from overcooked_ai_pcg.gen_lvl import DocplexFailedError, generate_lvl
from overcooked_ai_pcg.helper import run_overcooked_game
from overcooked_ai_pcg.LSI import bc_calculate

import subprocess
import ast

import subprocess
import ast

from overcooked_ai_py.utils import MergePlanError


def print_mem_usage(info, worker_id):
    print(f"worker({worker_id}): Memory usage ({info}):",
          resource.getrusage(resource.RUSAGE_SELF).ru_maxrss)


def run_overcooked_eval(ind, visualize, elite_map_config, agent_configs,
                        algorithm_config, G_params, gan_state_dict, worker_id,
                        lvl_size):
    """
    Evaluates overcooked game by running a game and calculating relevant BC's.

    Args:
        ind (overcooked_ai_pcg.LSI.qd_algorithms.Individual): Individual
            generated by the algorithm for evaluate.
        visualize (bool): render the game(evaluation) or not
        elite_map_config: toml config object of the feature maps
        G_params: parameters for the GAN
        gan_state_dict: weights of the GAN
        worker_id (int): Worker ID to use.
        lvl_size (tuple): size of the level to generate. Currently only supports
                          (6, 9) and (10, 15)

    Returns:
        The individual that was passed in (ind), but with populated data fields.
    """
    # generate new level
    try:
        # if algorithm is MAP-Elites-Baseline, the unrepaired level should be
        # already generated in the algorithm
        if algorithm_config["name"] == "MAPELITES-BASE":
            ind.level = generate_lvl(
                1,
                lvl_int_unrepaired=ind.unrepaired_lvl,
                worker_id=worker_id,
                lvl_size=lvl_size,
                mode="random",
            )
        else:
            print_mem_usage("start", worker_id)

            generator = dcgan.DCGAN_G(**G_params)
            generator.load_state_dict(gan_state_dict)

            print_mem_usage("after loading GAN", worker_id)
            ind.level = generate_lvl(
                1,
                generator=generator,
                # since this vector originates from the algorithm actor, Ray makes it
                # read-only; thus, we should copy it so generate_lvl can do whatever it
                # wants with it
                latent_vector=ind.param_vector[:32].copy(),
                worker_id=worker_id,
                lvl_size=lvl_size,
                mode="GAN",
            )
            del generator

    except DocplexFailedError:
        print("worker(%d): The Docplex subprocess seems to have failed." %
              worker_id)
        return None
    except Exception:
        print("worker(%d): Something seems to have failed in generate_lvl." %
              worker_id)
        return None

    # ind.level = generate_rnd_lvl((6, 8), worker_id=self.id)

    fitnesses = []
    scores = []
    checkpoints = []
    player_workloads = []
    joint_actions = []
    concurr_actives = []
    stuck_times = []
    max_iter = max(
        [agent_config["Search"]["num_iter"] for agent_config in agent_configs])
    # run evaluation for all sets of agent configs
    # normalize the fitness if more than 1 sets are running
    for agent_config in agent_configs:
        if agent_config["Search"]["type"] == 'human':
            # generate human worker preference and adaptiveness
            # if the algorithm is MAP-Elites Baseline, these params are not
            # generated along with param vector, but rather generated directly
            if algorithm_config["name"] != "MAPELITES-BASE":
                ind.human_preference = ind.param_vector[32]
                ind.human_adaptiveness = ind.param_vector[33]

        print_mem_usage("after generating level", worker_id)

        # run simulation
        try:
            fitness, score, checkpoint, workload, joint_action, concurr_active, stuck_time = run_overcooked_game(
                ind,
                agent_config,
                render=visualize,
                worker_id=worker_id,
                num_iters=max_iter)

            fitnesses.append(fitness)
            scores.append(score)
            checkpoints.append(checkpoint)
            player_workloads.append(workload)
            joint_actions.append(joint_action)
            concurr_actives.append(concurr_active)
            stuck_times.append(stuck_time)
        except TimeoutError:
            print(
                "worker(%d): Level generated taking too much time to plan. Skipping"
                % worker_id)
            return None
        except MergePlanError:
            print("worker(%d): Merge plan failed. Skipping" % worker_id)
            return None

        # run the garbage collector after each simulation
        gc.collect()

    ind.fitnesses = tuple(fitnesses)
    ind.scores = tuple(scores)
    ind.checkpoints = tuple(checkpoints)
    ind.player_workloads = tuple(player_workloads)
    ind.joint_actions = tuple(joint_actions)
    ind.concurr_actives = tuple(concurr_actives)
    ind.stuck_times = tuple(stuck_times)
    # print("ind.fitnesses")
    # print(ind.fitnesses)
    # for unnormalized version, fitness is scale
    if len(agent_configs) == 1:
        ind.fitness = ind.fitnesses[0][0]
    # for normalized version, fitness is the difference between two runs
    elif len(agent_configs) == 2:
        if len(ind.fitnesses[0]) > 1:
            ind.fitnesses = np.array(ind.fitnesses)
            ind.fitness = (ind.fitnesses[0, :] - ind.fitnesses[1, :]).tolist()
        else:
            ind.fitness = ind.fitnesses[0][0] - ind.fitnesses[1][0]

    print("The fitness of the individual is: " + str(ind.fitness))

    print_mem_usage("after running overcooked game", worker_id)

    # calculate bc out of the game
    worker_id, ind = obtain_bc_values(worker_id, ind, elite_map_config)

    print_mem_usage("end", worker_id)
    gc.collect()
    return ind


def obtain_bc_values(worker_id, ind, elite_map_config):
    ind.features = []
    for bc in elite_map_config["Map"]["Features"]:
        # get the function that calculates bc
        bc_fn_name = bc["name"]
        bc_fn = getattr(bc_calculate, bc_fn_name)
        bc_val = bc_fn(ind)
        ind.features.append(bc_val)
    ind.features = tuple(ind.features)
    print("worker(%d): Game end; fitness = %s" % (worker_id, ind.fitness))

    return worker_id, ind
